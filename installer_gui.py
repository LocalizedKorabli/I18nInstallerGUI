# Korabli Localization Installer GUI
# Copyright © 2024 澪刻LocalizedKorabli
#
# This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General
# Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied
# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with this program. If not,
# see <https://www.gnu.org/licenses/>.
import ctypes
import hashlib
import json
import os
import shutil
import string
import subprocess
import sys
import threading
import time
import tkinter as tk
import urllib.request
import webbrowser
import winreg
# pip install urllib3==1.25.11
# The newer urllib has break changes.
import xml.etree.ElementTree as ET
import zipfile
from datetime import datetime
from optparse import OptionParser
from pathlib import Path
from tkinter import filedialog, font
from typing import Any, Dict, List, Tuple, Optional, Union

import polib
import pythoncom
import requests
import ttkbootstrap as ttk
import winshell
from tktooltip import ToolTip
from ttkbootstrap.dialogs.dialogs import Messagebox

mods_link = 'https://drive.google.com/drive/folders/1UB2FP_Ro7sM0uN-cKIImlvPdu-0W7kYc'
project_repo_link = 'https://github.com/LocalizedKorabli/Korabli-LESTA-I18N/'
installer_repo_link = 'https://github.com/LocalizedKorabli/I18nInstallerGUI/'

version = '0.2.3'

builtin_locale_config = '''<locale_config>
    <locale_id>ru</locale_id>
    <text_path>../res/texts</text_path>
    <text_domain>global</text_domain>
    <lang_mapping>
        <lang acceptLang="ru" egs="ru" fonts="EU" full="russian" languageBar="false" localeRfcName="ru" short="ru" />
    </lang_mapping>
</locale_config>
'''

builtin_paths_xml = r'''<root>
    <Paths>
        <Path>..\res_mods</Path>
        <Path key="15b8d" packages="..\..\..\res_packages" type="PFS">..\idx</Path>
        <Path key="35d52">..\res</Path>
        <Path key="77ee7" type="DLC">..\res_dlc</Path>
    </Paths>
</root>
'''

download_routes = {
    'r': {
        'gitlab': {
            'url': 'https://gitlab.com/localizedkorabli/korabli-lesta-i18n/-/raw/main/Localizations/latest/',
            'direct': False
        },
        'github': {
            'url': 'https://github.com/LocalizedKorabli/Korabli-LESTA-I18N/raw/main/Localizations/latest/',
            'direct': False
        }
    },
    'pt': {
        'gitlab': {
            'url': 'https://gitlab.com/localizedkorabli/korabli-lesta-i18n-publictest/-/raw/main'
                   '/Localizations/latest/',
            'direct': False
        },
        'github': {
            'url': 'https://github.com/LocalizedKorabli/Korabli-LESTA-I18N-PublicTest/raw/main/Localizations'
                   '/latest/',
            'direct': False
        }
    }
}

server_regions_dict: Dict[str, Tuple[str, bool]] = {
    'WOWS.RU.PRODUCTION': ('ru', True),
    'WOWS.RPT.PRODUCTION': ('ru', False),
    'WOWS.WW.PRODUCTION': ('zh_sg', True),
    'WOWS.PT.PRODUCTION': ('zh_sg', False),
    'WOWS.CN.PRODUCTION': ('zh_cn', True)
}

launcher_dict: Dict[str, str] = {
    'lgc_api.exe': 'Mir Korabley (WoWs RU)',
    'wgc_api.exe': 'World of Warships (WG)',
    'wgc360_api.exe': 'World of Warships (CN360)',
    'steam_api64.dll': 'Steam Client'
}

base_path: str = getattr(sys, '_MEIPASS', os.path.abspath(os.path.dirname(__file__)))
resource_path: str = os.path.join(base_path, 'resources')
game_path_current = '<WORKING DIR>'
game_path_unknown = '<SELECT GAME DIR>'
au_shortcut_path_desktop = '<USER DESKTOP / DEFAULT NAME>'

msg_game_path_may_be_invalid = '''The selected game directory is missing the necessary game files,
it may not be the World of Warships installation directory.'''
msg_auto_update_notification = '''Automatic Update Principle:

The program generates a shortcut at the location specified by the user. By launching the installer in automatic 
update mode through this shortcut, the installer will perform an update operation if the remote localization package 
version is newer than the local version, and then automatically start the game.

Note:

1. Automatic updates will only be executed when you launch the game using the generated shortcut.

2. The target game path, game type, i18n source, and other parameters for the update script are based on your 
settings during this installation of the localization.

3. If the i18n source is specified as a local file, no update script will be generated.

4. The shortcut is generated by default as "User Desktop/Launch World of Warships.lnk", but you can choose a 
different location if you prefer.'''

tooltip_auto_search_clients = 'Automatically detect the Mir Korabley clients installed on the computer.'

tooltip_select_game_path = 'Manually select the game dir'

tooltip_detect_game_type = 'Auto-detect game region and type'

tooltip_src_gitlab = 'Download i18n package from GitLab (mirror)'

tooltip_src_github = 'Download i18n package from GitHub'

tooltip_src_local = 'Select local i18n package'

tooltip_mo_path_selection = 'Manually select the i18n package to be installed'

tooltip_ee_selection = '''Experience Enhancement(EE) provides some visual enhancements.'''

tooltip_mods_selection = '''Modifications allow user to partially modify the localization file.'''

tooltip_isolation = '''When the isolation mode is activated,
the program will apply mods from
<GAME DIR>/i18n_installer/mods'''

tooltip_mods_dir = 'Open Mods Dir'

tooltip_download_mods = 'Visit Mods Market (WIP)'

tooltip_au = '''If the automatic update option is checked,
a shortcut will be generated based on the settings
of THIS installation after the localization is successfully installed.
This shortcut will be used to launch the installer in automatic update mode.'''

tooltip_launch_game = 'Launch WoWs'

tooltip_about = 'Visit the repository of the i18n packages'

tooltip_source_code = 'Visit the repository of the I18nInstaller'

tooltip_license = 'This project is licensed under the GNU-AGPL-3.0'


class LocalizationInstallerAuto:
    no_gui: bool
    no_run: bool
    game_path: Path
    is_release: bool
    use_ee: bool
    use_mods: bool
    isolation: bool
    download_src: str
    server_region: str
    installing: bool = True

    install_progress_bar: ttk.Progressbar
    install_progress: tk.DoubleVar

    def __init__(self, parent: tk.Tk, options: Any):
        self.no_gui = bool(options.no_gui)
        if self.no_gui:
            parent.overrideredirect(True)
            parent.withdraw()
        self.root = parent
        self.root.title(f'I18nInstaller[AutoUpdate] v{version}')
        self.no_run = bool(options.no_run)
        self.game_path = Path(options.game_path)
        self.is_release = bool(options.is_release)
        self.use_ee = bool(options.use_ee)
        self.use_mods = bool(options.use_mods)
        self.isolation = bool(options.isolation)
        self.download_src = options.download_src
        self.server_region = options.server_region
        self.install_progress = tk.DoubleVar()

        ttk.Label(self.root, text='AutoUpdate: ') \
            .grid(row=0, column=0, columnspan=1, padx=10, pady=10, sticky=tk.W)
        self.install_progress_bar = ttk.Progressbar(parent, variable=self.install_progress, maximum=100.0,
                                                    style='success-striped', length=780)
        self.install_progress_bar.grid(row=1, column=0, columnspan=4, padx=10, pady=10)

        self.safely_set_install_progress(progress=0.0)

        self.update_timer()
        # print(f'{self.game_path}+{self.is_release}+{self.use_ee}+{self.use_mods}+{self.download_src}+{self.server_region}')

        tr = threading.Thread(target=self.do_install_update)
        tr.start()

    def do_install_update(self):
        _install_update(self,
                        self.game_path, self.is_release,
                        self.use_ee, self.use_mods,
                        self.isolation, self.download_src,
                        self.server_region)
        self.installing = False

    def safely_set_install_progress(self, progress: Optional[float] = None):
        self.root.after(0, self.install_progress.set(progress))

    def update_timer(self):
        if not self.installing:
            self.root.destroy()
        self.root.after(1000, self.update_timer)

    def on_closed(self):
        if not self.no_run:
            run_launcher(find_launcher(self.game_path)[0])


class LocalizationInstaller:
    # Components
    install_progress_bar: ttk.Progressbar

    # GUI Related Variables
    localization_status_1st: tk.StringVar
    localization_status_2nd: tk.StringVar
    server_region: tk.StringVar
    is_release: tk.BooleanVar
    download_source: tk.StringVar
    ee_selection: tk.BooleanVar
    mods_selection: tk.BooleanVar
    isolation: tk.BooleanVar
    mo_path: tk.StringVar
    install_progress_text: tk.StringVar
    download_progress_text: tk.StringVar
    install_progress: tk.DoubleVar
    game_path: tk.StringVar

    # Variables
    global_settings: Dict[str, Any] = None
    choice: Dict[str, Any] = None
    last_installed_i18n_version = ''
    run_dirs: Dict[str, str] = {}
    is_installing: bool = False
    game_launcher_file: Optional[Path] = None
    available_game_paths: List[str] = []
    user_desktop_path: Optional[Path] = None

    def __init__(self, parent: tk.Tk):
        self.root = parent
        self.root.title(f'I18nInstaller v{version}')

        self.game_path = tk.StringVar()
        self.localization_status_1st = tk.StringVar()
        self.localization_status_2nd = tk.StringVar()
        self.server_region = tk.StringVar()
        self.is_release = tk.BooleanVar()
        self.download_source = tk.StringVar()
        self.ee_selection = tk.BooleanVar()
        self.mods_selection = tk.BooleanVar()
        self.isolation = tk.BooleanVar()
        self.mo_path = tk.StringVar()
        self.install_progress_text = tk.StringVar()
        self.game_launcher_status = tk.StringVar()
        self.download_progress_text = tk.StringVar()
        self.install_progress = tk.DoubleVar()
        self.gen_auto_update = tk.BooleanVar()
        self.gen_auto_update_path = tk.StringVar()

        # 游戏目录
        ttk.Label(parent, text='Game Dir: ') \
            .grid(row=0, column=0, columnspan=1, padx=5, pady=5, sticky=tk.W)

        self.game_path_combo = ttk.Combobox(parent, width=26, textvariable=self.game_path, state='readonly')
        self.game_path_combo.grid(row=0, column=1, columnspan=3, padx=5, pady=5, sticky=tk.W)
        ToolTip(self.game_path_combo, msg=lambda: get_str_from_optional_path(self.get_game_path(), 'Game Dir: '),
                delay=1.0)

        self.refresh_path_combo()

        self.auto_search = ttk.Button(parent, text='Auto Detect', command=lambda: self.find_game(overwrite=False),
                                      style='success')
        self.auto_search.grid(row=1, column=2, columnspan=1, sticky='news')
        ToolTip(self.auto_search, msg=tooltip_auto_search_clients, delay=1.0)

        self.game_path_button = ttk.Button(parent, text='Select Dir', command=self.choose_path, style='warning')
        self.game_path_button.grid(row=1, column=3, columnspan=1, sticky='news')
        ToolTip(self.game_path_button, msg=tooltip_select_game_path, delay=1.0)

        # 游戏版本
        ttk.Label(parent, text='Game Version / I18n Version') \
            .grid(row=1, column=0, columnspan=4, padx=5, pady=5, sticky=tk.W)

        # 汉化状态
        self.localization_status_label_1st = ttk.Label(parent, textvariable=self.localization_status_1st)
        self.localization_status_label_1st.grid(row=3, column=0, columnspan=4, padx=5, pady=5, sticky=tk.W)
        self.localization_status_label_2nd = ttk.Label(parent, textvariable=self.localization_status_2nd)
        self.localization_status_label_2nd.grid(row=4, column=0, columnspan=4, padx=5, pady=5, sticky=tk.W)

        # 游戏区服
        ttk.Label(parent, text='Game Region: ').grid(row=5, column=0, padx=5, pady=5, sticky=tk.W)

        # 游戏区服选项
        ttk.Radiobutton(parent, text='RU', variable=self.server_region, value='ru') \
            .grid(row=5, column=1, padx=5, pady=5, sticky=tk.W)
        ttk.Radiobutton(parent, text='WG', variable=self.server_region, value='zh_sg', style='warning') \
            .grid(row=5, column=2, padx=5, pady=5, sticky=tk.W)
        ttk.Radiobutton(parent, text='CN360', variable=self.server_region, value='zh_cn', style='danger') \
            .grid(row=5, column=3, padx=5, pady=5, sticky=tk.W)

        # 游戏类型
        ttk.Label(parent, text='Game Type: ').grid(row=6, column=0, padx=5, pady=5, sticky=tk.W)

        # 游戏类型选项
        ttk.Radiobutton(parent, text='Live', variable=self.is_release, value=True, style='success') \
            .grid(row=6, column=1, padx=5, pady=5, sticky=tk.W)
        ttk.Radiobutton(parent, text='Public Test', variable=self.is_release, value=False, style='danger') \
            .grid(row=6, column=2, padx=5, pady=5, sticky=tk.W)

        self.detect_game_type_button = ttk.Button(parent, text='Auto Detect',
                                                  command=lambda: self.detect_game_status(manually=True))
        self.detect_game_type_button.grid(row=6, column=3, sticky='news')
        ToolTip(self.detect_game_type_button, tooltip_detect_game_type, delay=1.0)

        # 下载源
        ttk.Label(parent, text='I18n Source: ').grid(row=7, column=0, padx=5, pady=5, sticky=tk.W)
        # 下载源选项
        self.gitlab_button = ttk.Radiobutton(parent, text='GitLab', variable=self.download_source,
                                             value='gitlab', style='warning')
        self.gitlab_button.grid(row=8, column=0, padx=5, pady=5, sticky=tk.W)
        ToolTip(self.gitlab_button, tooltip_src_gitlab, delay=1.0)
        self.github_button = ttk.Radiobutton(parent, text='GitHub', variable=self.download_source,
                                             value='github', style='dark')
        self.github_button.grid(row=8, column=1, padx=5, pady=5, sticky=tk.W)
        ToolTip(self.github_button, tooltip_src_github, delay=1.0)
        self.local_file_button = ttk.Radiobutton(parent, text='Local File', variable=self.download_source,
                                                 value='local')
        self.local_file_button.grid(row=8, column=3, padx=5, pady=5, sticky=tk.W)
        ToolTip(self.local_file_button, tooltip_src_local, delay=1.0)

        # 体验增强包/汉化修改包
        self.ee_check_button = ttk.Checkbutton(parent, text='Install EE', variable=self.ee_selection)
        self.ee_check_button.grid(row=10, column=0, columnspan=2, padx=10, pady=5, sticky=tk.W)
        ToolTip(self.ee_check_button, tooltip_ee_selection, delay=1.0)
        self.mods_check_button = ttk.Checkbutton(parent, text='Apply Mods', variable=self.mods_selection)
        self.mods_check_button.grid(row=11, column=0, columnspan=2, padx=10, pady=5, sticky=tk.W)
        ToolTip(self.mods_check_button, tooltip_mods_selection, delay=1.0)
        self.isolation_check_button = ttk.Checkbutton(parent, text='Isolation Mode', variable=self.isolation)
        self.isolation_check_button.grid(row=12, column=0, columnspan=2, padx=10, pady=5, sticky=tk.W)
        ToolTip(self.isolation_check_button, tooltip_isolation, delay=1.0)
        self.mods_dir_button = ttk.Button(parent, text='Mods Dir', command=self.open_mods_folder)
        self.mods_dir_button.grid(row=12, column=2, columnspan=1, sticky='news')
        ToolTip(self.mods_dir_button, tooltip_mods_dir, delay=1.0)
        self.download_mods_button = ttk.Button(parent, text='Download Mods', style='info',
                                               command=lambda: webbrowser.open_new_tab(mods_link))
        self.download_mods_button.grid(row=12, column=3, columnspan=1, sticky='news')
        ToolTip(self.download_mods_button, tooltip_download_mods, delay=1.0)

        # 安装路径选择/下载进度
        self.mo_path_entry = ttk.Entry(parent, textvariable=self.mo_path, width=36, state='readonly')
        self.mo_path_selection_button = ttk.Button(parent, text='Select File', command=self.choose_mo)
        ToolTip(self.mo_path_selection_button, tooltip_mo_path_selection, delay=1.0)
        self.download_progress_label = ttk.Label(parent, text='Download: ')
        self.download_progress_info = ttk.Label(parent, textvariable=self.download_progress_text)

        # 安装/更新按钮
        self.install_button = ttk.Button(parent, text='Install I18n', command=self.install_update,
                                         style=ttk.SUCCESS)
        self.install_button.grid(row=13, column=0, pady=5, sticky='news')

        # 安装进度
        ttk.Label(parent, textvariable=self.install_progress_text).grid(row=13, column=1, columnspan=3,
                                                                        padx=5, sticky=tk.W)

        self.install_progress_bar = ttk.Progressbar(parent, variable=self.install_progress, maximum=100.0,
                                                    style='success-striped', length=400)
        self.install_progress_bar.grid(row=14, column=0, columnspan=4, padx=10, pady=5)

        # 自动更新
        self.gen_auto_update_button = ttk.Checkbutton(parent, text='Auto Update', variable=self.gen_auto_update)
        self.gen_auto_update_button.grid(row=15, column=0, columnspan=1, padx=10, pady=10)
        ToolTip(self.gen_auto_update_button, tooltip_au, delay=1.0)

        self.gen_auto_update_entry = ttk.Entry(parent, textvariable=self.gen_auto_update_path, width=18,
                                               state='readonly')
        ToolTip(self.gen_auto_update_entry, msg=lambda: get_str_from_optional_path(
            self.get_au_shortcut_path(), 'Shortcut dir: '
        ), delay=1.0)

        self.choose_au_shortcut_path_button = ttk.Button(parent, text='Select Path', command=self.choose_au_shortcut_path,
                                                         style='dark')

        # 启动游戏
        self.launch_button = ttk.Button(parent, text='Launch WoWs', command=self.launch_game, style=ttk.WARNING)
        self.launch_button.grid(row=16, column=0, pady=5, sticky='news')
        ToolTip(self.launch_button, tooltip_launch_game, delay=1.0)

        # 启动器状态
        ttk.Label(parent, textvariable=self.game_launcher_status).grid(row=16, column=1, columnspan=3,
                                                                       padx=5, sticky=tk.W)

        # 相关链接
        self.about_button = ttk.Button(parent, text='About',
                                       command=lambda: webbrowser.open_new_tab(project_repo_link),
                                       style=ttk.INFO)
        self.about_button.grid(row=17, column=0, pady=5, sticky='news')
        ToolTip(self.about_button, tooltip_about, delay=1.0)

        self.src_button = ttk.Button(parent, text='Source Code',
                                     command=lambda: webbrowser.open_new_tab(installer_repo_link),
                                     style=ttk.DANGER)
        self.src_button.grid(row=17, column=1, pady=5, sticky='news')
        ToolTip(self.src_button, tooltip_source_code, delay=1.0)

        # 版权声明
        self.license_text = ttk.Label(parent, text='© 2025 LocalizedKorabli')
        self.license_text.grid(row=17, column=2, columnspan=3, pady=5)
        ToolTip(self.license_text, tooltip_license, delay=1.0)

        # 根据汉化来源选项显示或隐藏安装路径选择
        self.download_source.trace('w', self.on_download_source_changed)
        # 更换游戏路径时，刷新数据
        self.game_path.trace('w', self.on_game_path_changed)
        # 非莱斯塔服客户端无需安装体验增强包
        self.server_region.trace('w', self.on_server_region_or_game_type_changed)
        self.is_release.trace('w', self.on_server_region_or_game_type_changed)
        # 自动更新被勾选时，显示快捷方式生成目录选项
        self.gen_auto_update.trace('w', self.on_au_selected)

        mkdir('i18n_installer/downloads')
        mkdir('i18n_installer/mods')
        mkdir('i18n_installer/processed')
        mkdir('i18n_installer/settings')

        global_settings = self.parse_global_settings()
        last_saved_paths = global_settings.get('available_game_paths')
        if isinstance(last_saved_paths, list):
            for saved_path in last_saved_paths:
                self.available_game_paths.append(saved_path)
            self.refresh_path_combo()
        self.game_path.set(global_settings.get('last_game_path'))
        self.game_path_combo.current()
        self.find_game()
        self.on_game_path_changed()

        self.gen_auto_update_path.set(au_shortcut_path_desktop)

        self.reset_progress()
        self.game_launcher_status.set(find_launcher(self.get_game_path())[1])

    def reset_progress(self):
        self.safely_set_download_progress_text('Idle')
        self.safely_set_install_progress_text('Idle')
        self.safely_set_install_progress(progress=0.0)

    def safely_set_download_progress_text(self, msg: str):
        self.root.after(0, self.download_progress_text.set(msg))

    def safely_set_install_progress_text(self, msg: str):
        self.root.after(0, self.install_progress_text.set('Progress: ' + msg))

    def safely_set_install_progress(self, progress: Optional[float] = None):
        self.root.after(0, self.install_progress.set(progress))

    def refresh_path_combo(self):
        self.game_path_combo['values'] = list(dict.fromkeys(self.available_game_paths))

    def get_game_path(self, find: bool = True) -> Optional[Path]:
        game_path_str = self.game_path.get()
        if game_path_str == game_path_unknown:
            return self.find_game() if find else None
        if game_path_str == game_path_current:
            return Path('.')
        return Path(game_path_str)

    def on_download_source_changed(self, *args):
        if self.download_source.get() == 'local':
            self.mo_path_entry.grid(row=9, column=0, columnspan=3, padx=5)
            self.mo_path_selection_button.grid(row=9, column=3, sticky='news')
            self.download_progress_label.grid_forget()
            self.download_progress_info.grid_forget()
            self.gen_auto_update.set(False)
            self.gen_auto_update_button.configure(state='disabled')
        else:
            self.download_progress_label.grid(row=9, column=0, padx=5, pady=5, sticky=tk.W)
            self.download_progress_info.grid(row=9, column=1, pady=5, columnspan=3, sticky=tk.W)
            self.mo_path_entry.grid_forget()
            self.mo_path_selection_button.grid_forget()
            self.gen_auto_update_button.configure(state='')

    def on_game_path_changed(self, *args) -> None:
        self.reset_progress()
        self.gen_auto_update.set(False)
        if self.game_path.get() == game_path_unknown:
            return

        game_path = self.get_game_path()
        if not game_path:
            return

        self.detect_game_status()
        parse_game_version(self, game_path)
        self.game_launcher_file = find_launcher(game_path)[0]

        mkdir(game_path.joinpath('i18n_installer/settings'))
        mkdir(game_path.joinpath('i18n_installer/mods'))

        choice = self.parse_choice(use_cache=False)
        if not choice:
            return

        self.server_region.set(choice.get('server_region', 'ru'))
        self.is_release.set(choice.get('is_release', True))
        self.download_source.set(choice.get('download_source', 'gitlab'))
        self.ee_selection.set(choice.get('use_ee', True))
        self.mods_selection.set(choice.get('apply_mods', True))
        self.isolation.set(choice.get('isolation', False))

    def on_server_region_or_game_type_changed(self, *args):
        self.ee_check_button.configure(state=('' if self.supports_ee() else 'disabled'))

    # def on_mods_selection_changed(self, *args):
    #     self.isolation_check_button.configure(state='' if self.mods_selection.get() else 'disabled')

    def on_au_selected(self, *args):
        if self.gen_auto_update.get():
            Messagebox.ok(msg_auto_update_notification)
            self.gen_auto_update_entry.grid(row=15, column=1, columnspan=2)
            self.choose_au_shortcut_path_button.grid(row=15, column=3, columnspan=1, sticky='news')
        else:
            self.gen_auto_update_entry.grid_forget()
            self.choose_au_shortcut_path_button.grid_forget()

    def get_au_shortcut_path(self) -> Optional[Path]:
        shortcut_str = self.gen_auto_update_path.get()

        if shortcut_str == au_shortcut_path_desktop:
            desktop_path = self.find_user_desktop()
            if not desktop_path:
                return None
            return desktop_path.joinpath('LaunchWoWs.lnk')

        return Path(shortcut_str)

    def supports_ee(self):
        # return self.server_region.get() == 'ru' and self.is_release.get()
        return self.server_region.get() == 'ru'

    def find_game(self, overwrite: bool = True) -> Optional[Path]:
        found_in_reg = self.find_from_reg()
        found_manually = self.find_manually()
        game_path_str = self.game_path.get()
        if not overwrite:
            return None
        if game_path_str != game_path_unknown:
            game_path = Path(game_path_str)
            if is_valid_game_path(game_path):
                return game_path
        if is_valid_game_path(Path('.')):
            self.game_path.set(game_path_current)
            self.available_game_paths.append(game_path_current)
            self.refresh_path_combo()
            return Path('.')
        if found_in_reg:
            reg_first = found_in_reg[0]
            self.game_path.set(str(reg_first.absolute()))
            return reg_first
        # Manually
        if found_manually:
            manually_first = found_manually[0]
            self.game_path.set(str(manually_first.absolute()))
            return manually_first
        return None

    def find_from_reg(self) -> List[Path]:
        try:
            with winreg.OpenKey(winreg.HKEY_CURRENT_USER, r'Software\Classes\lgc\DefaultIcon') as key:
                lgc_dir_str, _ = winreg.QueryValueEx(key, '')
                if lgc_dir_str is None:
                    # Try the default value
                    lgc_dir_str = r'C:\ProgramData\Lesta\GameCenter\lgc.exe'
                if ',' in lgc_dir_str:
                    lgc_dir_str = lgc_dir_str.split(',')[0]
                preferences_path = Path(lgc_dir_str).parent.joinpath('preferences.xml')
                if not preferences_path.is_file():
                    return []
                pref_root = ET.parse(preferences_path).getroot()
                games_block = pref_root.find('.//application/games_manager/games')
                games = games_block.findall('.//game')
                if not games:
                    return []
                path_strs = [game.find('working_dir').text for game in games if game.find('working_dir') is not None]
                path_strs_filtered = [dir_str for dir_str in path_strs if is_valid_game_path(Path(dir_str))]
                for path_str in path_strs_filtered:
                    self.available_game_paths.append(path_str)
                self.refresh_path_combo()
                return [Path(dir_str) for dir_str in path_strs_filtered]
        except Exception:
            pass

    def find_manually(self) -> List[Path]:
        found_manually: List[Path] = []
        drives = find_all_drives()
        for drive in drives:
            for possible_path in [
                Path(drive).joinpath('Games').joinpath('Korabli'),
                Path(drive).joinpath('Games').joinpath('Korabli_PT'),
                Path(drive).joinpath('Korabli'),
                Path(drive).joinpath('Korabli_PT'),
                Path(drive).joinpath('Program Files (x86)').joinpath('Steam')
                        .joinpath('steamapps').joinpath('common').joinpath('Korabli'),
                Path(drive).joinpath('Program Files (x86)').joinpath('Steam')
                        .joinpath('steamapps').joinpath('common').joinpath('Korabli_PT'),
                Path(drive).joinpath('Program Files').joinpath('Steam')
                        .joinpath('steamapps').joinpath('common').joinpath('Korabli'),
                Path(drive).joinpath('Program Files').joinpath('Steam')
                        .joinpath('steamapps').joinpath('common').joinpath('Korabli_PT'),
                Path(drive).joinpath('SteamLibrary').joinpath('steamapps').joinpath('common').joinpath('Korabli'),
                Path(drive).joinpath('SteamLibrary').joinpath('steamapps').joinpath('common').joinpath('Korabli_PT')
            ]:
                if is_valid_game_path(possible_path):
                    found_manually.append(possible_path)
        for found_path in found_manually:
            self.available_game_paths.append(str(found_path.absolute()))
        self.refresh_path_combo()
        return found_manually

    def popup_result(self, nothing_wrong: bool):
        if nothing_wrong:
            msg_response = Messagebox.show_question('Installation finished, launch the game?', 'Installation Finished',
                                                    alert=True, buttons=[
                    'Launch:primary',
                    'Cancel:secondary'
                ]
                                                    )
            if msg_response == 'Launch':
                self.launch_game()
        else:
            Messagebox.show_error('Installation failed. Check your network access and retry.', 'Installation Failed')

    def open_mods_folder(self) -> None:
        instance_path = self.get_game_path() if self.isolation.get() else Path('.')
        if not instance_path:
            return
        mods_folder = instance_path.joinpath('i18n_installer').joinpath('mods')
        mkdir(mods_folder)
        subprocess.run(['explorer', mods_folder.absolute()])

    def choose_path(self):
        game_path_chosen = filedialog.askdirectory(
            title='Select Game Dir',
            initialdir='.'
        )
        if game_path_chosen:
            if not is_valid_game_path(Path(game_path_chosen)):
                Messagebox.show_warning(msg_game_path_may_be_invalid)
            else:
                self.available_game_paths.append(game_path_chosen)
                self.refresh_path_combo()
            self.game_path.set(game_path_chosen)

    def choose_mo(self):
        mo_path = filedialog.askopenfilename(
            title='Select I18n Package',
            initialdir='.',
            filetypes=[('I18n Packages', ['*.mo', '*.zip']),
                       ('MO Localization File', '*.mo'),
                       ('Packaged Localization File', '*.zip')]
        )
        if mo_path:
            self.mo_path.set(mo_path)

    def choose_au_shortcut_path(self):
        desktop_path = self.find_user_desktop()
        default_shortcut_path = desktop_path.joinpath('LaunchWoWs.lnk')
        shortcut_path = filedialog.asksaveasfilename(
            title='Select the location to create the AutoUpdate shortcut.',
            initialfile=default_shortcut_path,
            initialdir=desktop_path,
            filetypes=[('Shortcut', '*.lnk')]
        )
        if shortcut_path:
            if str(Path(shortcut_path).absolute()) == str(self.get_au_shortcut_path().absolute()):
                return
            self.gen_auto_update_path.set(shortcut_path)

    def find_user_desktop(self) -> Optional[Path]:
        if not self.user_desktop_path:
            self.user_desktop_path = Path(os.path.expanduser("~/Desktop"))
        return self.user_desktop_path

    def install_update(self):
        if self.is_installing:
            Messagebox.show_warning('Already installing!', 'Installation')
            return
        self.is_installing = True
        tr = threading.Thread(target=self.do_install_update)
        tr.start()

    def do_install_update(self) -> None:
        if _install_update(self) and self.gen_auto_update.get():
            self.gen_au_script_and_shortcut()

    def gen_au_script_and_shortcut(self) -> None:
        src = self.download_source.get()
        if src == 'local':
            return
        game_path = str(self.get_game_path().absolute())
        release = '--release' if self.is_release.get() else ''
        ee = '--ee' if self.ee_selection.get() else ''
        mods = '--mods' if self.mods_selection.get() else ''
        isolation = '--isolation' if self.isolation.get() else ''
        region = self.server_region.get()

        pythoncom.CoInitialize()
        with winshell.shortcut(str(self.get_au_shortcut_path().absolute())) as link:
            link.path = str(sys.executable)
            link.description = 'Auto-update the I18n package and launch WoWs'
            icon_location = self.get_shortcut_icon_location(Path(game_path))
            if icon_location is not None:
                link.icon_location = icon_location
            link.arguments = f'--auto --gamepath "{game_path}" {release} {ee} {mods} {isolation} ' \
                             f'--region {region} --src "{src}"'
        pythoncom.CoUninitialize()

    def get_shortcut_icon_location(self, game_path: Path) -> Optional[Tuple[str, int]]:
        if not game_path.is_dir():
            return None
        game_file = game_path.joinpath('Korabli.exe')
        if game_file.is_file():
            return str(game_file.absolute()), 0
        else:
            game_file = game_path.joinpath('WorldOfWarships.exe')
            if game_file.is_file():
                return str(game_file.absolute()), 0
            else:
                return None

    def get_choice_template(self):
        self.detect_game_status()
        return {
            'server_region': self.server_region.get(),
            'is_release': self.is_release.get(),
            'download_source': 'gitlab',
            'use_ee': True,
            'apply_mods': True,
            'isolation': False
        }

    def get_global_settings_template(self):
        return {
            'last_game_path': game_path_unknown,
            'available_game_paths': [
                game_path_current
            ]
        }

    def detect_game_status(self, manually: bool = False):
        if not manually:
            self.server_region.set('ru')
            self.is_release.set(True)
        game_path = self.get_game_path()
        if not game_path:
            return
        game_info_file = game_path.joinpath('game_info.xml')
        if not game_info_file.is_file():
            self.detect_steam_game_status(game_path)
            return
        game_info = ET.parse(game_info_file)
        game_id = game_info.find('.//game/id')
        if game_id is None:
            return
        game_type: (str, bool) = server_regions_dict.get(
            game_id.text,
            # By default RU
            ('ru', 'PT.PRODUCTION' not in game_id.text)
        )
        self.server_region.set(game_type[0])
        self.is_release.set(game_type[1])

    def detect_steam_game_status(self, game_path: Path):
        if not game_path.joinpath('steam_api64.dll').is_file():
            return
        if game_path.joinpath('Korabli.exe').is_file():
            self.server_region.set('ru')
            self.is_release.set(True)
            return
        if game_path.joinpath('WorldOfWarships.exe').is_file():
            self.server_region.set('wg')
            self.is_release.set(True)

    def launch_game(self) -> None:
        if not self.game_launcher_file or not self.game_launcher_file.is_file():
            self.game_launcher_file = find_launcher(self.get_game_path())[0]
        if not self.game_launcher_file or not self.game_launcher_file.is_file():
            Messagebox.show_warning('Client not found!', 'Launch')
            return
        run_launcher(self.game_launcher_file)

    def parse_global_settings(self):
        if self.global_settings:
            return self.global_settings
        self.global_settings = {}
        global_settings_file = Path('i18n_installer/settings/global.json')
        if global_settings_file.is_file():
            try:
                with open(global_settings_file, 'r', encoding='utf-8') as f:
                    self.global_settings = json.load(f)
            except Exception:
                pass
        self.check_global_settings()
        return self.global_settings

    def check_global_settings(self):
        template = self.get_global_settings_template()
        for entry in ['last_game_path', 'available_game_paths']:
            if entry not in self.global_settings.keys():
                self.global_settings[entry] = template[entry]

    def save_global_settings(self):
        if self.global_settings:
            self.global_settings['last_game_path'] = self.game_path.get()
            self.global_settings['available_game_paths'] = list(dict.fromkeys(self.available_game_paths))
            self.global_settings['last_installed_i18n_version'] = self.last_installed_i18n_version
            with open('i18n_installer/settings/global.json', 'w', encoding='utf-8') as f:
                json.dump(self.global_settings, f, ensure_ascii=False, indent=4)

    def parse_choice(self, use_cache: bool = True) -> Optional[Dict[str, str]]:
        if use_cache and self.choice:
            return self.choice
        self.choice = {}
        game_path = self.get_game_path(find=False)
        if not game_path:
            return None
        choice_file = game_path.joinpath('i18n_installer/settings/choice.json')
        if os.path.isfile(choice_file):
            try:
                with open(choice_file, 'r', encoding='utf-8') as f:
                    self.choice = json.load(f)
            except Exception:
                pass
        self.check_choice()
        return self.choice

    def check_choice(self):
        template = self.get_choice_template()
        for choice in ['server_region', 'is_release', 'download_source', 'use_ee', 'apply_mods', 'isolation']:
            if choice not in self.choice.keys():
                self.choice[choice] = template[choice]

    def save_choice(self) -> None:
        if self.choice and self.game_path.get() != game_path_unknown:
            game_path = self.get_game_path(find=False)
            if not game_path:
                return
            self.choice['is_release'] = self.is_release.get()
            self.choice['download_source'] = self.download_source.get()
            self.choice['use_ee'] = self.ee_selection.get()
            self.choice['apply_mods'] = self.mods_selection.get()
            self.choice['isolation'] = self.isolation.get()
            with open(game_path.joinpath('i18n_installer/settings/choice.json'), 'w', encoding='utf-8') as f:
                json.dump(self.choice, f, ensure_ascii=False, indent=4)

    def on_closed(self):
        self.save_global_settings()


def mkdir(t_dir: Any):
    os.makedirs(t_dir, exist_ok=True)


def process_modification_file(source_mo, mod_path: str,
                              json_mods_d: Dict[str, Union[str, List[str]]], json_mods_m: Dict[str, str]) -> bool:
    translated = None
    is_json_mod = False
    if mod_path.endswith('po'):
        translated = polib.pofile(mod_path)
    elif mod_path.endswith('mo'):
        translated = polib.mofile(mod_path)
    elif mod_path.endswith('l10nmod') or mod_path.endswith('json'):
        is_json_mod = True

    if translated:
        translation_dict_singular: Dict[str, polib.MOEntry] = {entry.msgid: entry for entry in translated if
                                                               entry.msgid and not entry.msgid_plural}
        translation_dict_plural: Dict[str, polib.MOEntry] = {entry.msgid: entry for entry in translated if
                                                             entry.msgid and entry.msgid_plural}
        singular_count = len(translation_dict_singular)
        plural_count = len(translation_dict_plural)
        for entry in source_mo:
            if not entry.msgid:
                continue
            if singular_count == 0 and plural_count == 0:
                break
            if entry.msgid_plural and entry.msgid_plural in translation_dict_plural:
                target_strs = translation_dict_plural[entry.msgid].msgstr_plural
                del translation_dict_plural[entry.msgid]
                plural_count -= 1
                entry.msgstr_plural = target_strs
            elif entry.msgid and entry.msgid in translation_dict_singular:
                target_str = translation_dict_singular[entry.msgid].msgstr
                del translation_dict_singular[entry.msgid]
                singular_count -= 1
                if entry.msgid == 'IDS_RIGHTS_RESERVED':
                    continue
                entry.msgstr = target_str
        if singular_count > 0 or plural_count > 0:
            for s_e in translation_dict_singular:
                source_mo.append(translation_dict_singular[s_e])
            for p_e in translation_dict_plural:
                source_mo.append(translation_dict_plural[p_e])
    elif is_json_mod:
        try:
            with open(mod_path, 'r', encoding='utf-8') as f:
                json_mod = json.load(f)
            append_json_mod(json_mod, json_mods_d, json_mods_m)
        except Exception:
            pass
    return translated or is_json_mod


def append_json_mod(json_mod: Dict[str, Any],
                    json_mods_d: Dict[str, Union[str, List[str]]], json_mods_m: Dict[str, str]):
    if 'replace' in json_mod.keys():
        replaces = json_mod.get('replace')
        if isinstance(replaces, Dict):
            for r_k in replaces.keys():
                r_v = replaces[r_k]
                if isinstance(r_v, str) or isinstance(r_v, List):
                    json_mods_d[r_k] = r_v
    if 'words' in json_mod.keys():
        words = json_mod.get('words')
        if isinstance(words, Dict):
            for w_k in words.keys():
                w_v = words[w_k]
                if isinstance(w_v, str):
                    json_mods_m[w_k] = w_v


def process_json_mods(source_mo, json_mods_d_replace: Dict[str, Union[str, List[str]]],
                      json_mods_m_replace: Dict[str, str]):
    for entry in source_mo:
        if not entry.msgid:
            continue
        if entry.msgid_plural:
            for m_k in json_mods_m_replace:
                m_v = json_mods_m_replace[m_k]
                msgstrs: Dict[int, str] = entry.msgstr_plural
                should_modify = False
                for i in msgstrs.keys():
                    if m_k in msgstrs.get(i):
                        msgstrs[i] = msgstrs.get(i).replace(m_k, m_v)
                        should_modify = True
                if should_modify:
                    entry.msgstr_plural = msgstrs
            for d_k in json_mods_d_replace:
                if entry.msgid == d_k:
                    target_text = json_mods_d_replace[d_k]
                    if isinstance(target_text, str):
                        list_l = len(entry.msgstr_plural)
                        entry.msgstr_plural = {i: target_text for i in range(list_l)}
                    elif isinstance(target_text, List):
                        entry.msgstr_plural = {i: target_text[i] for i in range(len(target_text))}
        else:
            for m_k in json_mods_m_replace:
                m_v = json_mods_m_replace[m_k]
                msgstr = entry.msgstr
                if m_k in msgstr:
                    entry.msgstr = msgstr.replace(m_k, m_v)
            for d_k in json_mods_d_replace:
                if entry.msgid == d_k:
                    target_text = json_mods_d_replace[d_k]
                    if isinstance(target_text, str):
                        entry.msgstr = target_text


def is_valid_game_path(game_path: Path) -> bool:
    game_info_file = game_path.joinpath('game_info.xml')
    if not game_info_file.is_file() or not game_path.joinpath('bin').is_dir():
        # For Steam Clients
        return game_path.joinpath('steam_api64.dll').is_file() and game_path.joinpath('bin').is_dir()
    try:
        game_info = ET.parse(game_info_file)
        game_id = game_info.find('.//game/id')
        if game_id is None:
            return False
        return 'WOWS' in game_id.text
    except Exception:
        return False


def is_valid_build_dir(build_dir: Path) -> bool:
    res_dir = Path(build_dir).joinpath('res')
    if not res_dir.is_dir():
        return False
    return os.path.isfile(res_dir.joinpath('locale_config.xml'))


def check_sha256(mo_path: Path, sha256: str):
    return get_sha256_for_mo(mo_path) == sha256


def find_all_drives() -> List[str]:
    return ['%s:/' % d for d in string.ascii_uppercase if os.path.exists('%s:' % d)]


def get_sha256_for_mo(mo_path: Path):
    with open(mo_path, 'rb') as file:
        return hashlib.sha256(file.read()).hexdigest()


# Returns whether the update was successful
def _install_update(
        gui: Union[LocalizationInstaller, LocalizationInstallerAuto],
        game_path: Path = None,
        is_release: bool = False,
        use_ee: bool = False,
        use_mods: bool = False,
        isolation: bool = False,
        download_src: str = '',
        server_region: str = 'ru'
) -> bool:
    full_gui = isinstance(gui, LocalizationInstaller)
    if full_gui:
        game_path = gui.get_game_path()
        is_release = gui.is_release.get()
        use_ee = gui.ee_selection.get()
        use_mods = gui.mods_selection.get()
        isolation = gui.isolation.get()
        download_src = gui.download_source.get()
        server_region = gui.server_region.get()
    gui.safely_set_install_progress(progress=0.0)
    if not game_path or not is_valid_game_path(game_path):
        if full_gui:
            gui.root.after(0, Messagebox.show_error, 'Invalid game dir, unable to proceed.', 'Installation')
            gui.is_installing = False
        else:
            Messagebox.show_error('Invalid game dir, unable to update.', 'AutoUpdate')
        return False
    if full_gui:
        run_dirs = gui.run_dirs.keys()
    else:
        run_dirs = parse_game_version(None, game_path)[0]
    if not run_dirs or len(run_dirs) == 0:
        if full_gui:
            gui.root.after(0, Messagebox.show_error, 'No game version found, unable to proceed.', 'Installation')
            gui.is_installing = False
        else:
            Messagebox.show_error('No game version found, unable to update.', 'AutoUpdate')
        return False
    for run_dir in run_dirs:
        build_path = game_path.joinpath('bin').joinpath(run_dir)
        fix_paths(build_path.joinpath('bin64'))
        target_path = build_path.joinpath('res_mods')
        mkdir(target_path)
        if full_gui:
            gui.safely_set_install_progress_text('Installing locale_config')
        with open(target_path.joinpath('locale_config.xml'), 'w', encoding='utf-8') as file:
            file.write(builtin_locale_config)
    gui.safely_set_install_progress(progress=20.0)
    if full_gui:
        gui.safely_set_install_progress_text('Installing locale_config - Finished')

    proxies = {scheme: proxy for scheme, proxy in urllib.request.getproxies().items()}

    # EE
    if full_gui:
        use_ee = gui.supports_ee() and gui.ee_selection.get()
    if use_ee:
        if full_gui:
            gui.safely_set_install_progress_text('Installing EE')
            gui.safely_set_download_progress_text('Downloading EE - Connecting')
        output_file = Path('i18n_installer').joinpath('downloads').joinpath('LK_EE.zip')
        ee_ready = False
        try:
            response = requests.get('https://gitlab.com/localizedkorabli/korabli-lesta-i18n/-/raw/main'
                                    '/BuiltInMods/LKExperienceEnhancement.zip', stream=True,
                                    proxies=proxies, timeout=5000)
            status = response.status_code
            if status == 200:
                if full_gui:
                    gui.safely_set_download_progress_text('Downloading EE - Downloading')
                with open(output_file, 'wb') as f:
                    for chunk in response.iter_content(chunk_size=1024):
                        if chunk:
                            f.write(chunk)
                ee_ready = True
                if full_gui:
                    gui.safely_set_download_progress_text('Downloading EE - Finished')
            elif full_gui:
                gui.safely_set_download_progress_text(f'Downloading EE - Failed ({status})')
        except requests.exceptions.RequestException:
            if full_gui:
                gui.safely_set_download_progress_text('Downloading EE - Request Error')
        if ee_ready:
            for run_dir in run_dirs:
                target_path = game_path.joinpath('bin').joinpath(run_dir).joinpath('res_mods')
                with zipfile.ZipFile(output_file, 'r') as mo_zip:
                    process_possible_gbk_zip(mo_zip)
                    mo_zip.extractall(target_path)
            if full_gui:
                gui.safely_set_install_progress_text('Installing EE - Finished')
        elif full_gui:
            gui.safely_set_install_progress_text('Installing EE - Failed')
    # 汉化包
    gui.safely_set_install_progress(progress=30.0)
    if full_gui:
        gui.safely_set_install_progress_text('Installing I18n Package')
    nothing_wrong = True
    # remote_version = ''
    # downloaded_mo = ''
    local_src = download_src == 'local'
    fetched_file = None
    if not local_src:
        if full_gui:
            gui.safely_set_download_progress_text('Downloading I18n Package')
        download_link_base = download_routes['r' if is_release else 'pt'][download_src]['url']
        # Check and Fetch
        downloaded: Tuple = check_version_and_fetch_mo(None,
                                                       None if full_gui else parse_game_version(None, game_path)[1],
                                                       download_link_base, proxies)
        if downloaded[2] is True:
            return True
        fetched_file = downloaded[0]
        remote_version = downloaded[1]
    else:
        if full_gui:
            fetched_file = gui.mo_path.get()
        remote_version = 'local'
    if not fetched_file:
        if full_gui:
            gui.safely_set_install_progress(0.0)
            gui.safely_set_install_progress_text('Installing I18n Package - Unexpected File')
            gui.is_installing = False
        Messagebox.show_error('In case local files selected as the I18n source, '
                              '\nplease manually start the installer to proceed with the installation.')
        return False
    dir_total = len(run_dirs)
    dir_progress = 1
    for run_dir in run_dirs:
        execution_time = str(time.time_ns())
        target_path = game_path.joinpath('bin').joinpath(run_dir).joinpath('res_mods')
        version_info_file: Optional[Path] = None
        if fetched_file.endswith('.zip'):
            extracted_path = Path('i18n_installer').joinpath('downloads').joinpath('extracted_mo')
            mkdir(extracted_path)
            info_fetched = False
            with zipfile.ZipFile(fetched_file, 'r') as mo_zip:
                process_possible_gbk_zip(mo_zip)
                info_files = [info for info in mo_zip.filelist if info.filename.endswith('version.info')]
                if info_files:
                    info_file_name = info_files[0].filename
                    mo_zip.extract(info_file_name, extracted_path)
                    version_info_file = extracted_path.joinpath(info_file_name)
                    info_fetched = True
                mo_files = [mo for mo in mo_zip.filelist if mo.filename.endswith('.mo')]
                if mo_files:
                    mo_file_name = mo_files[0].filename
                    mo_zip.extract(mo_file_name, extracted_path)
                    fetched_file = os.path.join(extracted_path, mo_file_name)
            if info_fetched and version_info_file and version_info_file.is_file():
                with open(version_info_file, 'r', encoding='utf-8') as f:
                    remote_version = f.readline()
        if not fetched_file.endswith('.mo') or not os.path.isfile(fetched_file):
            if full_gui:
                gui.safely_set_install_progress_text('Installing I18n Package - Unexpected File')
            nothing_wrong = False
            break
        if nothing_wrong:
            if full_gui:
                gui.safely_set_download_progress_text('Downloading I18n Package - Finished')
            mods = get_mods(use_mods, game_path, run_dir, game_path if isolation else Path('.'))
            fetched_file = parse_and_apply_mods(gui, fetched_file, mods, execution_time, dir_progress, dir_total)
            cache_path = 'i18n_installer/cache'
            if os.path.isdir(cache_path):
                shutil.rmtree(cache_path)
            if fetched_file == '':
                if full_gui:
                    gui.safely_set_install_progress_text('Installing I18n Package - Corrupted File')
                nothing_wrong = False
                break
        if nothing_wrong:
            if full_gui:
                gui.safely_set_install_progress_text(f'Installing I18n Package - Moving ({dir_progress}/{dir_total})')
            mo_dir = target_path.joinpath('texts').joinpath(server_region).joinpath('LC_MESSAGES')
            mkdir(mo_dir)
            old_mo = mo_dir.joinpath('global.mo')
            old_mo_backup = mo_dir.joinpath('global.mo.old')
            # if not is_release:
            #     if not os.path.isfile(old_mo_backup) and os.path.isfile(old_mo):
            #         shutil.copy(old_mo, old_mo_backup)
            shutil.copy(fetched_file, old_mo)

            info_path = game_path.joinpath('bin').joinpath(run_dir).joinpath('i18n')
            mkdir(info_path)
            installation_info_file = info_path.joinpath('installation.info')
            with open(installation_info_file, 'w', encoding='utf-8') as f:
                f.writelines([
                    remote_version,
                    '\n',
                    str(old_mo.absolute()),
                    '\n',
                    get_sha256_for_mo(old_mo)
                ])
                try:
                    float(remote_version)
                except ValueError:
                    f.write(f'\n{time.time()}')
        dir_progress += 1
    if full_gui:
        gui.is_installing = False
    if nothing_wrong:
        gui.safely_set_install_progress(progress=100.0)
        if full_gui:
            gui.available_game_paths.append(gui.game_path.get())
            gui.save_global_settings()
            gui.save_choice()
    if full_gui:
        gui.safely_set_install_progress_text('Finished!' if nothing_wrong else 'Failed!')
        parse_game_version(gui, gui.get_game_path())
        gui.root.after(0, gui.popup_result, nothing_wrong)
    return nothing_wrong


def fix_paths(build_dir: Path):
    if not build_dir.is_dir():
        return
    with open(build_dir.joinpath('paths.xml'), 'w', encoding='utf-8') as file:
        file.write(builtin_paths_xml)


# Returns (output_file: str, remote_version: str, should_skip: bool)
def check_version_and_fetch_mo(
        gui: Optional[LocalizationInstaller],
        i18n_versions: Optional[List[str]],
        download_link_base: str,
        proxies: Dict
) -> (str, str, bool):
    full_gui = gui is not None
    remote_version: str = 'latest'
    if full_gui:
        gui.safely_set_download_progress_text('Downloading I18n Package - Fetching Version')
    try:
        response = requests.get(download_link_base + 'version.info', stream=True, proxies=proxies, timeout=5000)
        status = response.status_code
        if status == 200:
            info_file = 'i18n_installer/downloads/version.info'
            with open(info_file, 'wb') as f:
                for chunk in response.iter_content(chunk_size=1024):
                    if chunk:
                        f.write(chunk)
            with open(info_file, 'r', encoding='utf-8') as f:
                remote_version = f.readline().strip()
                if full_gui:
                    gui.safely_set_download_progress_text(f'Downloading I18n Package - Latest=={remote_version}')
                elif compare_with_local(remote_version, i18n_versions):
                    return '', '', True

    except requests.exceptions.RequestException:
        pass
    valid_version = remote_version != 'latest'
    if not valid_version:
        if full_gui:
            gui.safely_set_download_progress_text(f'Downloading I18n Package - Unknown Version')
    mo_file_name = f'{remote_version}.mo'
    output_file = f'i18n_installer/downloads/{mo_file_name}'
    # Check existed
    if full_gui:
        if valid_version and gui.last_installed_i18n_version == remote_version:
            if os.path.isfile(output_file):
                try:
                    if polib.mofile(output_file):
                        gui.safely_set_download_progress_text(f'Downloading I18n Package - Using Cached')
                        return output_file, remote_version, False
                except Exception:
                    pass
    # Download from remote
    output_file = download_mo_from_remote(download_link_base + mo_file_name, output_file, proxies)
    if valid_version and output_file == '':
        # valid_version = False
        remote_version = 'latest'
        mo_file_name = f'{remote_version}.mo'
        output_file = f'i18n_installer/downloads/{mo_file_name}'
        output_file = download_mo_from_remote(download_link_base + mo_file_name, output_file, proxies)
    return output_file, remote_version, False


# Returns False if update needed
def compare_with_local(remote_version: str, local_versions: Optional[List[str]]):
    if not local_versions:
        return False
    try:
        rv = remote_version.split('.')
        rgv = int(rv[0])
        rlv = int(rv[1])
    except ValueError:
        return False
    for local_version in local_versions:
        try:
            lv = local_version.split('.')
            lgv = int(lv[0])
            llv = int(lv[1])
        except ValueError:
            return False
        if lgv < rgv:
            return False
        if llv < rlv:
            return False
    return True


def get_mods(mods_selection: bool, game_path: Path, run_dir: str, instance_dir: Path) -> List[str]:
    if not mods_selection:
        return []
    installer_mods_dir = instance_dir.joinpath('i18n_installer').joinpath('mods')
    compat_mods_dir_0 = game_path.joinpath('bin').joinpath(run_dir).joinpath('res_mods') \
        .joinpath('texts').joinpath('i18n_mods')
    compat_mods_dir_1 = game_path.joinpath('bin').joinpath(run_dir).joinpath('res_mods') \
        .joinpath('texts').joinpath('mods')
    if not installer_mods_dir.is_dir() and not compat_mods_dir_0.is_dir() and not compat_mods_dir_1.is_dir():
        return []
    file_list = []
    mkdir('i18n_installer/cache')
    scan_mods(file_list, installer_mods_dir)
    scan_mods(file_list, compat_mods_dir_0)
    scan_mods(file_list, compat_mods_dir_1)
    return file_list


def scan_mods(file_list: List[str], mods_dir: Path) -> None:
    extracted_list = []
    for root0, _, files0 in os.walk(mods_dir):
        for name0 in files0:
            if name0.endswith(('.mo', '.po', '.json', '.i18nmod')):
                file_list.append(os.path.abspath(os.path.join(root0, name0)))
            elif name0.endswith('.zip'):
                try:
                    mod_name = os.path.basename(name0).replace('.zip', '')
                    extracted_cache = f'i18n_installer/cache/{mod_name}'
                    with zipfile.ZipFile(os.path.join(root0, name0), 'r') as mod_zip:
                        process_possible_gbk_zip(mod_zip)
                        mod_files = [mod_file for mod_file in mod_zip.filelist if
                                     mod_file.filename.split('/')[-1].endswith(('.mo', '.po', '.json', '.i18nmod'))]
                        for mod_file in mod_files:
                            mod_zip.extract(mod_file, extracted_cache)

                    extracted_list.append(extracted_cache)
                except Exception as ex:
                    print(ex)
        for extracted_cache in extracted_list:
            for root1, _, files1 in os.walk(extracted_cache):
                for name1 in files1:
                    if name1.endswith(('.mo', '.po', '.json', '.i18nmod')):
                        file_list.append(os.path.abspath(os.path.join(root1, name1)))


def parse_and_apply_mods(gui: Union[LocalizationInstaller, LocalizationInstallerAuto], downloaded_mo: str,
                         mods: List[str],
                         execution_time: str,
                         dir_progress: int,
                         dir_total: int) -> str:
    full_gui = isinstance(gui, LocalizationInstaller)
    try:
        downloaded_mo_instance = polib.mofile(downloaded_mo)
    except Exception:
        return ''
    mods_count = len(mods)
    if mods_count == 0:
        gui.safely_set_install_progress(90.0)
        return downloaded_mo
    if full_gui:
        gui.safely_set_install_progress_text(f'Installing I18n Package - Applying Mods ({str(dir_progress)}/{str(dir_total)})')
    modded_file_name = f'i18n_installer/processed/modified_{execution_time}.mo'
    if os.path.isfile(modded_file_name):
        return modded_file_name
    applied_mods = 0
    json_mods_d_replace: Dict[str, Union[str, List[str]]] = {}
    json_mods_m_replace: Dict[str, str] = {}
    for mod in mods:
        try:
            applied = process_modification_file(downloaded_mo_instance, mod, json_mods_d_replace, json_mods_m_replace)
        except Exception:
            pass
        if applied:
            applied_mods += 1
            gui.safely_set_install_progress(
                30.0 + 60.0 * ((dir_progress - 1) / dir_total + applied_mods / (mods_count * dir_total))
            )
    process_json_mods(downloaded_mo_instance, json_mods_d_replace, json_mods_m_replace)

    for file in os.listdir('i18n_installer/processed/'):
        try:
            os.remove(file)
        except Exception:
            continue
    downloaded_mo_instance.save(modded_file_name)
    return modded_file_name


def download_mo_from_remote(download_link: str, output_file: str, proxies: Dict) -> str:
    try:
        response = requests.get(download_link, stream=True, proxies=proxies, timeout=5000)
        status = response.status_code
        if status == 200:
            with open(output_file, 'wb') as f:
                for chunk in response.iter_content(chunk_size=1024):
                    if chunk:
                        f.write(chunk)
            return output_file
    except requests.exceptions.RequestException:
        return ''


# Returns (run_dirs: List[str], installed_i18ns: List[str])
def parse_game_version(gui: Optional[LocalizationInstaller], game_path: Optional[Path]) -> Tuple[List[str], List[str]]:
    gui_on = gui is not None
    if gui_on:
        gui.run_dirs = {}
        gui.localization_status_1st.set('No Game Version Found')
        gui.localization_status_2nd.set('')
    v_1st = ''
    v_2nd = ''
    if gui_on:
        game_path = gui.get_game_path()
    if not game_path:
        return [], []
    bin_path = game_path.joinpath('bin')
    if not bin_path.is_dir():
        return [], []
    for v_dir_b in os.listdir(bin_path):
        v_dir = str(v_dir_b)
        # v_dir_num = 0
        try:
            v_dir_num = int(v_dir)
            if not is_valid_build_dir(bin_path.joinpath(v_dir)):
                continue
        except ValueError:
            continue
        if not v_1st:
            v_1st = v_dir
        elif int(v_1st) > v_dir_num:
            if not v_2nd or int(v_2nd) < v_dir_num:
                v_2nd = v_dir
        else:
            v_2nd = v_1st
            v_1st = v_dir
    if not v_1st:
        return [], []
    _1st_i18n_status = get_local_i18n_version(gui, game_path, v_1st)
    if gui_on:
        gui.run_dirs[v_1st] = _1st_i18n_status[0]
        gui.localization_status_1st.set(_1st_i18n_status[1])
    if v_2nd:
        _2nd_i18n_status = get_local_i18n_version(gui, game_path, v_2nd)
        if gui_on:
            gui.run_dirs[v_2nd] = _2nd_i18n_status[0]
            gui.localization_status_2nd.set(_2nd_i18n_status[1])
        return [v_1st, v_2nd], [_1st_i18n_status[0], _2nd_i18n_status[0]]
    return [v_1st], [_1st_i18n_status[0]]


# 返回：(汉化版本号: str, 汉化状态: str)
def get_local_i18n_version(gui: Optional[LocalizationInstaller], game_path: Path, run_dir: str) -> (str, str):
    gui_on = gui is not None
    installation_info_file = game_path.joinpath('bin').joinpath(run_dir).joinpath('i18n') \
        .joinpath('installation.info')
    if not installation_info_file.is_file():
        return '', f'{run_dir} - Uninstalled'
    with open(installation_info_file, 'r', encoding='utf-8') as f:
        parsed_version = f.readline().strip()
        mo_path = Path(f.readline().strip())
        if not mo_path.is_file():
            return '', f'{run_dir} - Uninstalled'
        mo_sha256 = f.readline().strip()
    if gui_on:
        gui.last_installed_i18n_version = parsed_version
    not_parsable = False
    to_return = parsed_version, f'{run_dir} - {parsed_version}'
    try:
        float(parsed_version)
    except ValueError:
        not_parsable = True
    if not_parsable:
        try:
            inst_time = float(f.readline())
            time_formatted = datetime.fromtimestamp(inst_time).strftime('%Y-%m-%d %H:%M')
            to_return = '', f'{run_dir} - Unknown version, time: {time_formatted}'
        except ValueError:
            to_return = '', f'{run_dir} - Unknown version & time'

    return to_return if check_sha256(mo_path, mo_sha256) else ('', to_return[1] + '(Maybe Tampered)')


def get_str_from_optional_path(target_path: Optional[Path], prefix: str = '') -> str:
    if not target_path:
        return ''
    return prefix + str(target_path.absolute())


# Returns (launcher_file: Path, launcher_status: str)
def find_launcher(game_path: Optional[Path]) -> (Optional[Path], str):
    if game_path:
        for launcher in launcher_dict.keys():
            launcher_file = game_path.joinpath(launcher)
            if launcher_file.is_file():
                return launcher_file, launcher_dict.get(launcher)
    return None, 'Client Not Found'


def run_launcher(launcher_file: Optional[Path]) -> None:
    if not launcher_file:
        return
    path_text = str(launcher_file.absolute())
    if path_text.endswith('.exe'):
        subprocess.run(launcher_file)
    elif path_text.endswith('.dll'):
        parent_path = launcher_file.parent
        if not parent_path.is_dir():
            return
        target_executable = parent_path.joinpath('WorldOfWarships.exe')
        if target_executable.is_file():
            subprocess.run(target_executable)
        else:
            target_executable = parent_path.joinpath('Korabli.exe')
            if target_executable.is_file():
                subprocess.run(target_executable)


def is_admin():
    try:
        return ctypes.windll.shell32.IsUserAnAdmin()
    except Exception:
        return False


def run():
    parser = OptionParser()
    parser.add_option('--auto', dest='auto', action='store_true', default=False)
    parser.add_option('--nogui', dest='no_gui', action='store_true', default=False)
    parser.add_option('--norun', dest='no_run', action='store_true', default=False)
    parser.add_option('--gamepath', dest='game_path')
    parser.add_option('--release', dest='is_release', action='store_true', default=False)
    parser.add_option('--ee', dest='use_ee', action='store_true', default=False)
    parser.add_option('--mods', dest='use_mods', action='store_true', default=False)
    parser.add_option('--isolation', dest='isolation', action='store_true', default=False)
    parser.add_option('--src', dest='download_src')
    parser.add_option('--region', dest='server_region')
    options, _ = parser.parse_args()

    if options.auto is False:
        root = ttk.Window()
        icon = os.path.join(resource_path, 'icon.ico')
        root.iconbitmap(default=icon)
        root.iconbitmap(bitmap=icon)
        configure_font()
        half_screen_width = int(root.winfo_screenwidth() / 2) - 234
        half_screen_height = int(root.winfo_screenheight() / 2) - 359
        root.geometry(f'+{half_screen_width}+{half_screen_height}')
        app = LocalizationInstaller(root)
        root.mainloop()
        app.on_closed()
    else:
        root = ttk.Window()
        icon = os.path.join(resource_path, 'icon.ico')
        root.iconbitmap(default=icon)
        root.iconbitmap(bitmap=icon)
        configure_font()
        scr_width = 800
        scr_height = 100
        half_screen_width = int((root.winfo_screenwidth() - scr_width) / 2)
        half_screen_height = int((root.winfo_screenheight() - scr_height) / 2)
        root.geometry(f'{scr_width}x{scr_height}+{half_screen_width}+{half_screen_height}')
        app = LocalizationInstallerAuto(root, options)
        root.mainloop()
        app.on_closed()


def configure_font():
    pass
    # font_list = list(font.families())
    # if 'SimHei' in font_list:
    #     do_configure_font('SimHei')
    # elif '黑体' in font_list:
    #     do_configure_font('黑体')
    # elif 'DengXian' in font_list:
    #     do_configure_font('DengXian')
    # elif '等线' in font_list:
    #     do_configure_font('等线')


def do_configure_font(family: str):
    ttk.font.nametofont('TkDefaultFont').configure(family=family)
    ttk.font.nametofont('TkTextFont').configure(family=family)
    ttk.font.nametofont('TkFixedFont').configure(family=family)


def process_possible_gbk_zip(zip_file: zipfile.ZipFile):
    name_to_info = zip_file.NameToInfo
    for name, info in name_to_info.copy().items():
        real_name = name.encode('cp437').decode('gbk')
        if real_name != name:
            info.filename = real_name
            del name_to_info[name]
            name_to_info[real_name] = info
    return zip_file


if __name__ == '__main__':
    dev_env = sys.executable.endswith('python.exe')
    if dev_env:
        run()
    else:
        os.chdir(Path(sys.executable).parent)
        if is_admin():
            run()
        else:
            ctypes.windll.shell32.ShellExecuteW(None, "runas", sys.executable, " ".join(sys.argv[1:]), None, 1)

# pyinstaller -w -i resources/icon.ico --add-data "resources\*;resources" --version-file=version_file.txt installer_gui.py --clean
